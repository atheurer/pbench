#!/bin/bash
# -*- mode: shell-script; indent-tabs-mode: t; sh-basic-offset: 8; sh-indentation: 8; sh-indent-for-case-alt: + -*-

# Author: Andrew Theurer
#
# This is a script to run a network traffic generator like MoonGen or TRex.
# It is intended to test a network function, like a bridge or router.
# 
# Hardware prerequisites:
# - A Linux host with 1 to 2 network adapters.  These adapters must be either Intel XL710 or Intel 82599
#   Ideally this host should have x86-64 processors (current or previous generation) 1GB HW pages, and PCI-E v2 or v3
# - A "device-under-test" (DUT) which network traffic will pass through.
#   The DUT will need to be configured to pass traffic before running this benchmark script
#

# This script attempts to automate potentially a very large number of tests
# This script will take multiple samples of the same test type and try to achieve a standard deviation of <3%
# This script will repeat a test type 6 times in order to try to achieve target stddev.
# If a run (with several samples) fails the stddev, its directory is appended with -fail
# This script will also generate a "results.txt" with a table of all
# results, efficiency, and other stats.

pbench_cmd="$@"
script_path=`dirname $0`
script_name=`basename $0`
pbench_bin="`cd ${script_path}/..; /bin/pwd`"

# source the base script
. "$pbench_bin"/base

benchmark_name="trafficgen"
if [ -z "$trafficgen_dir" ]; then
	trafficgen_dir="/root/lua-trafficgen/MoonGen"
fi
if [ ! -d "$trafficgen_dir" ]; then
	error_log "The MoonGen directory, $trafficgen_dir, does not exist as a directory"
	exit 1
fi
benchmark_bin=/usr/local/bin/$benchmark_name

# Every bench-script follows a similar sequence:
# 1) process bench script arguments
# 2) ensure the right version of the benchmark is installed
# 3) gather pre-run state
# 4) run the benchmark and start/stop perf analysis tools
# 5) gather post-run state
# 6) postprocess benchmark data
# 7) postprocess analysis tool data

# Defaults
traffic_engine="trex-txrx" # can be either trex-txrx or moongen-txrx
benchmark_run_dir=""
test_types="throughput-latency"
traffic_directions="bidirec"
max_drop_pcts="0"
rates=""
devices="" # the network devices as PCI location IDs, like "0000:04:00.0,0000:04:00.1"
dst_ips=""
src_ips=""
dst_macs=""
src_macs=""
encap_dst_ips=""
encap_src_ips=""
encap_dst_macs=""
encap_src_macs=""
frame_sizes="64" # size in bytes of the Ethernet frame inccluding CRC
config=""
nr_flows="1024"
nr_samples=5
maxstddevpct=5 # maximum allowable standard deviation in percent
max_failures=6 # after N failed attempts to hit below $maxstddevpct, move on to the nest test
search_runtime=60
validation_runtime=120
postprocess_only=n
start_iteration_num=1
keep_failed_tool_data="y"
tar_nonref_data="n"
orig_cmd="$*"
tool_group=default
install_only="n"
one_shot="n"

# Process options and arguments
opts=$(getopt -q -o c: --longoptions "traffic-engine:,devices:,rate:,rates:,max-drop-pct:,max-drop-pcts:,install,start-iteration-num:,config:,nr-flows:,test-type:,traffic-direction:traffic-directions:,search-runtime:,validation-runtime:,frame-size:,frame-sizes:,samples:,max-stddev:,max-failures:,postprocess-only:,run-dir:,tool-group:,one-shot,src-macs:,src-ips:,dst-macs:,dest-ips:,encap-src-macs:,encap-src-ips:,encap-dst-macs:,encapdst-ips:,vlan-ids:,overlay-ids:,overlay-types:,flow-mods:" -n "getopt.sh" -- "$@")
if [ $? -ne 0 ]; then
	printf -- "$*\n"
	printf "\n"
	printf "\t${benchmark_name}: you specified an invalid option\n\n"
	printf "\tThe following options are available:\n\n"
	#                   1         2         3         4         5         6         7         8
	#          12345678901234567890123456789012345678901234567890123456789012345678901234567890
	printf -- "\n"
	printf -- "trafficgen general test options\n"
	printf -- "-------------------------------\n"
	printf -- "\n"
	printf -- "--test-type=str\n"
	printf -- "  What type of test to run: throughput, latency, or throughput-latency\n"
	printf -- "  Default $test_type\n"
	printf -- "  throuhgput: find max throuhgput with a binary search\n"
	printf -- "  latency: find latency at a specified packet rate\n"
	printf -- "  throughput-latency: first find max throuhgput with a binary search, then find\n"
	printf -- "  latency at the max throughput\n"
	printf -- "\n"
	printf -- "--traffic-engine=str\n"
	printf -- "  The traffic generation engine to use (trex-txrx or moongen-txrx)\n"
	printf -- "  Default is $traffic_engine\n"
	printf -- "\n"
	printf -- "--devices=str,str\n"
	printf -- "  List of 2 DPDK devices to use, by PCI location ID (0000:04:00.0,0000:04:00.1)\n"
	printf -- "  This script will attempt to bind the device to vfio-pci kernel module.\n"
	printf -- "  You must ensure your system has IOMMU enabled.\n"
	printf -- "\n"
	printf -- "--one-shot\n"
	printf -- "  Run one test for throughput at specified rate\n"
	printf -- "\n"
	printf -- "--search-runtime=int\n"
	printf -- "  Measurement period in seconds when searching for max throughput\n"
	printf -- "  Default is $search_runtime\n"
	printf -- "\n"
	printf -- "--validation-runtime=int\n"
	printf -- "  Measurement period in seconds when running final validation or a latency test\n"
	printf -- "  Default is $validation_runtime\n"
	printf -- "\n\n"
	printf -- "      The follwoing options can take 1 or more values and will control how many\n"
	printf -- "      tests will be conducted.  For example, the following options:\n"
	printf -- "\n"
	printf -- "        --rates=1,2 --traffic-directions=unidirec,bidirec --max-drop-pcts=0,1\n"
	printf -- "        --frame-sizes=64,256 --nr-flows=1024,65536\n"
	printf -- "\n"
	printf -- "      would produce 32 different test permutations\n"
	printf -- "\n"
	printf -- "--rate[s]=float[,float]\n"
	printf -- "  A list of rates in millions of packets/sec for latency or --one-shot tests,\n"
	printf -- "  or the start rate for a binary search.\n"
	printf -- "\n"
	printf -- "--traffic-direction[s]=str[,str]\n"
	printf -- "  A list of one or more: unidirec or bidirec (default $traffic_directions)\n"
	printf -- "  unidirec: packets will Tx out the 1st device and Rx in the 2nd device\n"
	printf -- "  biidirec: packets will Tx out the both devices and Rx in both devices\n"
	printf -- "\n"
	printf -- "--max-drop-pct[s]=fl,[fl]\n"
	printf -- "  A list of maximum allowed percentage of dropped frames\n"
	printf -- "  Default is $max_drop_pcts\n"
	printf -- "\n"
	printf -- "--frame-sizes=str[,str]\n"
	printf -- "  A list of Ethernet frame sizes (including CRC) in bytes\n"
	printf -- "  Default is $frame_sizes\n"
	printf -- "\n"
	printf -- "--nr-flows=int\n"
	printf -- "  Number of packet flows to run. Default is $nr_flows\n"
	printf -- "\n\n"
	#                   1         2         3         4         5         6         7         8
	#          12345678901234567890123456789012345678901234567890123456789012345678901234567890
	printf -- "trafficgen options that control packet contents\n"
	printf -- "-----------------------------------------------\n"
	printf -- "\n"
	printf -- "    The values provided for the following options correspond to the devices\n"
	printf -- "    device list (--devices).  For example\n"
	printf -- "\n"
	printf -- "      --devices=0000:04:00.0,0000:04:00.1 --src-ips=10.0.0.1,8.0.0.1\n"
	printf -- "\n"
	printf -- "    In the example above, device 0000:04:00.0 would use source IP address 10.0.0.1\n"
	printf -- "    and device 0000:04:00.1 would use source IP adress 8.0.0.1\n"
	printf -- "\n"
	printf -- "--src-macs=MAC,MAC\n"
	printf -- "  A list of two source MAC addresses\n"
	printf -- "\n"
	printf -- "--src-ips=IP,IP\n"
	printf -- "  A list of two source IP addresses\n"
	printf -- "\n"
	printf -- "--dst-macs=MAC,MAC\n"
	printf -- "  A list of two destination MAC addresses\n"
	printf -- "\n"
	printf -- "--dst-ips=IP,IP\n"
	printf -- "  A list of two destination IP addresses\n"
	printf -- "\n"
	printf -- "--encap-src-macs=MAC,MAC\n"
	printf -- "  A list of two source MAC addresses for the encapsulated network. Only used in\n"
	printf -- "  conjuction with an overlay network like VxLAN\.n"
	printf -- "\n"
	printf -- "--encap-src-ips=IP,IP\n"
	printf -- "  A list of two source IP addresses for the encapsulated network.  Only used in\n"
	printf -- "  conjuction with an overlay network like VxLAN.\n"
	printf -- "\n"
	printf -- "--encap-dst-macs=MAC,MAC\n"
	printf -- "  A list of two destination MAC addresses for the encapsulated network.  Only\n"
	printf -- "  used on conjuction with an overlay network like VxLAN.\n"
	printf -- "\n"
	printf -- "--encap-dst-ips=IP,IP\n"
	printf -- "  A list of two destination IP addresses for the encapsulated network.  Only\n"
	printf -- "  used on conjuction with an overlay network like VxLAN.\n"
	printf -- "\n"
	printf -- "--vlan-ids=[int][,int]\n"
	printf -- "  If a value is provided, the corresponding device will use a VLAN tag when\n"
	printf -- "  transmitting and expect received packets to also have the VLAN tag\n"
	printf -- "\n"
	printf -- "--overlay-ids=[int][,int]\n"
	printf -- "  If a value is provided, the corresponding device will encapsulate the packet\n"
	printf -- "  and use VNI = value provided when transmitting packets.  Received packets\n"
	printf -- "  for the this device are expected to be encapsulated and use same VNI.  This\n"
	printf -- "  option must be used with --overlay-type option\n"
	printf -- "\n"
	#                   1         2         3         4         5         6         7         8
	#          12345678901234567890123456789012345678901234567890123456789012345678901234567890
	printf -- "--overlay-types\n"
	printf -- "  Per device specification of overlay network type, can be \"none\", or skipped,\n"
	printf -- "  or \"VxLAN\".  If \"VxLAN\" is used, --overlay-ids must also be used as well\n"
	printf -- "  as --encap-[src|dst]-[macs|ips] options.  When using an overlay, the\n"
	printf -- "  device-under-test must have the matching configuration.  For example, if\n"
	printf -- "  --overlay-types=none,vxlan is used, the device-under-test would receive\n"
	printf -- "  non-overlay packets on its first device, encapsulate the packets, and send\n"
	printf -- "  the packet out the second device.  Packets received by the second device are\n"
	printf -- "  expected to already be encapsulated, and the device-under-test would\n"
	printf -- "  decapsulate them and send them out the first device.\n"
	printf -- "\n"
	printf -- "--flow-mods=str[,str]\n"
	printf -- "  A list of IP packet header fields which are used to implement unique flows.\n"
	printf -- "  All fields listed here are changed in unison, for example if \"src-ip,src-mac\"\n"
	printf -- "  are used, the first packet will have a source IP of 192.168.0.X and source MAC\n"
	printf -- "  of 01:02:03:04:X:06.  The second packet will have a source IP of\n"
	printf -- "  192.168.0.(X+1) and source MAC of 01:02:03:04:(X+1):06. The list of available\n"
	printf -- "  flow mods are: src-ip,src-mac,src-port,dst-port,encap-src-mac,encap-src-ip\n"
	printf -- "  Note that the encap-* flow mods are only viable for overlay network tests like\n"
	printf -- "  VxLAN, and alter the inner packet header.\n"
	printf -- "  The maximum number of unique flows may be limited by the traffic-engine used.\n"
	printf -- "  For trex-txrx, it is 16.7 million.  Trex-txrx modifies the 2nd, 3rd, and 4th\n"
	printf -- "  octet in the IP addresses and the 3rd, 4th, and 5th octet in the MAC addresses\n"
	printf -- "  When using source or destination ports numbers, the range is limited to 1-32768\n"
	printf -- "  and higher flow counts will \"roll\" over back to 1\n"
	printf -- "\n\n"
	printf -- "options common in most pbench benchmark scripts\n"
	printf -- "-----------------------------------------------\n"
	printf -- "\n"
	printf -- "--config=str\n"
	printf -- "  Name of the test config (i.e. jumbo_frames_and_network_throughput)\n"
	printf -- "\n"
	printf -- "--samples=int\n"
	printf -- "  The number of times each different test is run (to compute average)\n"
	printf -- "\n\n"
	printf -- "--max-failures=int\n"
	printf -- "  The maximm number of failures to get below stddev\n"
	printf -- "\n"
	printf -- "--max-stddev=int\n"
	printf -- "  The maximm percent stddev allowed to pass\n"
	printf -- "\n"
	printf -- "--postprocess-only=y|n\n"
	printf -- "  Don't run the benchmark, but postprocess data from previous test\n"
	printf -- "\n"
	printf -- "--run-dir=str\n"
	printf -- "  Optionally specify what directory should be used (usually only used if\n"
	printf -- "  postprocess-only=y)\n"
	printf -- "\n"
	printf -- "--start-iteration-num=int\n"
	printf -- "  Optionally skip the first (n-1) tests\n"
	printf -- "\n"
	printf -- "--tool-group=str\n"
	printf -- "  Start/stop/post-process tools using this group\n"
	exit 1
fi
eval set -- "$opts"
debug_log "[$script_name]processing options"
while true; do
	case "$1" in
		--install)
		shift
		install_only="y"
		exit
		;;
		--tool-label-pattern)
		shift
		if [ -n "$1" ]; then
			tool_label_pattern="$1"
			shift
		fi
		;;
		--postprocess-only)
		shift
		if [ -n "$1" ]; then
			postprocess_only="$1"
			shift
		fi
		;;
		--run-dir)
		shift
		if [ -n "$1" ]; then
			benchmark_run_dir="$1"
			shift
		fi
		;;
		--max-stddev)
		shift
		if [ -n "$1" ]; then
			maxstddevpct="$1"
			shift
		fi
		;;
		--max-failures)
		shift
		if [ -n "$1" ]; then
			max_failures="$1"
			shift
		fi
		;;
		--samples)
		shift
		if [ -n "$1" ]; then
			nr_samples="$1"
			shift
		fi
		;;
		--nr-flows)
		shift
		if [ -n "$1" ]; then
			nr_flows="$1"
			shift
		fi
		;;
		--rate|--rates)
		shift
		if [ -n "$1" ]; then
			rates="$1"
			shift
		fi
		;;
		--max-drop-pct|--max-drop-pcts)
		shift
		if [ -n "$1" ]; then
			max_drop_pcts="$1"
			shift
		fi
		;;
		--traffic-direction|--traffic-directions)
		shift
		if [ -n "$1" ]; then
			traffic_directions="$1"
			shift
		fi
		;;
		--test-type)
		shift
		if [ -n "$1" ]; then
			test_type="$1"
			shift
		fi
		;;
		--tool-group)
		shift
		if [ -n "$1" ]; then
			tool_group="$1"
			shift
		fi
		;;
		--frame-sizes|--frame-sizes)
		shift
		if [ -n "$1" ]; then
			frame_sizes="$1"
			shift
		fi
		;;
		--search-runtime)
		shift
		if [ -n "$1" ]; then
			search_runtime="$1"
			shift
		fi
		;;
		--validation-runtime)
		shift
		if [ -n "$1" ]; then
			validation_runtime="$1"
			shift
		fi
		;;
		--devices)
		shift
		if [ -n "$1" ]; then
			devices="$1"
			shift
		fi
		;;
		--config)
		shift
		if [ -n "$1" ]; then
			config="$1"
			shift
		fi
		;;
		--start-iteration-num)
		shift
		if [ -n "$1" ]; then
			start_iteration_num=$1
			shift
		fi
		;;
		--one-shot)
		shift
		one_shot="y"
		;;
		--flow-mods)
		shift
		if [ -n "$1" ]; then
		    flow_mods="$1"
		    shift
		fi
		;;
		--vlan-ids)
		shift
		if [ -n "$1" ]; then
		    vlan_ids="$1"
		    shift
		fi
		;;
		--overlay-ids)
		shift
		if [ -n "$1" ]; then
		    overlay_ids="$1"
		    shift
		fi
		;;
		--overlay-types)
		shift
		if [ -n "$1" ]; then
		    overlay_types="$1"
		    shift
		fi
		;;
		--src-ips)
		shift
		if [ -n "$1" ]; then
		    src_ips="$1"
		    shift
		fi
		;;
		--src-macs)
		shift
		if [ -n "$1" ]; then
		    src_macs="$1"
		    shift
		fi
		;;
		--dst-ips)
		shift
		if [ -n "$1" ]; then
		    dst_ips="$1"
		    shift
		fi
		;;
		--dst-macs)
		shift
		if [ -n "$1" ]; then
		    dst_macs="$1"
		    shift
		fi
		;;
		--encap-src-ips)
		shift
		if [ -n "$1" ]; then
		    encap_src_ips="$1"
		    shift
		fi
		;;
		--encap-src-macs)
		shift
		if [ -n "$1" ]; then
		    encap_src_macs="$1"
		    shift
		fi
		;;
		--encap-dst-ips)
		shift
		if [ -n "$1" ]; then
		    encap_dst_ips="$1"
		    shift
		fi
		;;
		--encap-dst-macs)
		shift
		if [ -n "$1" ]; then
		    encap_dst_macs="$1"
		    shift
		fi
		;;
		--)
		shift
		break
		;;
		*)
		error_log "[$script_name] bad option, \"$1 $2\""
		break
		;;
	esac
done
if [[ -z "$benchmark_run_dir" ]]; then
	# We don't have an explicit run directory, construct one
	benchmark_fullname="${benchmark_name}_${config}_${date}"
	benchmark_run_dir="$pbench_run/${benchmark_fullname}"
else
	# We have an explicit run directory provided by --run-dir, so warn
	# the user if they also used --config
	if [[ ! -z "$config" ]]; then
		warn_log "[$script_name] ignoring --config=\"$config\" in favor of --rundir=\"$benchmark_run_dir\""
	fi
	benchmark_fullname=$(basename $benchmark_run_dir)
fi
benchmark_iterations="$pbench_tmp/${benchmark_fullname}.iterations"
mkdir -p $benchmark_run_dir/.running
# save a copy of the command, in case the test needs to be reproduced or post-processed again
echo "$script_name $pbench_cmd" >$benchmark_run_dir/$script_name.cmd
chmod +x $benchmark_run_dir/$script_name.cmd

total_iterations=0
for traffic_direction in `echo $traffic | sed -e s/,/" "/g`; do
	for max_drop_pct in `echo $max_drop_pcts | sed -e s/,/" "/g`; do
		for frame_size in `echo $frame_sizes | sed -e s/,/" "/g`; do
			for nr_flow in `echo $nr_flows | sed -e s/,/" "/g`; do
				((total_iterations++))
			done
		done
	done
done
echo "Total number of benchmark iterations: $total_iterations"
count=1
mkdir -p $benchmark_run_dir/.running
export benchmark_name config
pbench-collect-sysinfo --group=$tool_group --dir=$benchmark_run_dir beg
# start the server processes
if [ -z "$rates" ]; then
	# a rate of "none" is valid if this is a throuhgput test.  The opnfv-vsperf.lua
	# script will start with line-rate for the binary search
	rates="none"
fi
for rate in `echo $rates | sed -e s/,/" "/g`; do
	for traffic_direction in `echo $traffic | sed -e s/,/" "/g`; do
		for max_drop_pct in `echo $max_drop_pcts | sed -e s/,/" "/g`; do
			for frame_size in `echo $frame_sizes | sed -e s/,/" "/g`; do
				for nr_flow in `echo $nr_flows | sed -e s/,/" "/g`; do
					if [ $count -ge $start_iteration_num ]; then
						if [ "$test_type" == "latency" ]; then
							iteration="${count}-${test_type}-${traffic_direction}-${frame_size}B-${nr_flow}flows-${rate}Mpps"
						else 
							iteration="${count}-${test_type}-${traffic_direction}-${frame_size}B-${nr_flow}flows-${max_drop_pct}pct_drop"
						fi
                                                echo $iteration >> $benchmark_iterations
						iteration_dir="$benchmark_run_dir/$iteration"
						result_stddevpct=$maxstddevpct # this test case will get a "do-over" if the stddev is not low enough
						failures=0
						echo "Starting iteration[$iteration] ($count of $total_iterations)"
						log "Starting iteration[$iteration] ($count of $total_iterations)"
						while [[ $(echo "if (${result_stddevpct} >= ${maxstddevpct}) 1 else 0" | bc) -eq 1 ]]; do
							if [[ $failures -gt 0 ]]; then
								echo "Restarting iteration[$iteration] ($count of $total_iterations)"
								log "Restarting iteration[$iteration] ($count of $total_iterations)"
							fi
							mkdir -p $iteration_dir
							if [ "$postprocess_only" != "y" ]; then
								if [ $traffic_direction == "unidirec" ]; then
									bidirec_opt=false
								else
									bidirec_opt=true
								fi
								cfg_file="$iteration_dir/opnfv-vsperf-cfg.lua"
								echo "VSPERF {" >$cfg_file
								if [ "$rate" != "none" ]; then
        								echo "startRate = $rate," >>$cfg_file
								fi
        							echo "nrFlows = $nr_flow," >>$cfg_file
        							echo "testType = \"$test_type\"," >>$cfg_file
        							echo "runBidirec = $bidirec_opt," >>$cfg_file
								if [ "$test_type" == "latency" ]; then
									echo "latencyRunTime = $latency_runtime,">>$cfg_file
								else
        								echo "searchRunTime = $search_runtime,">>$cfg_file
        								echo "validationRunTime = $validation_runtime,">> $cfg_file
        								echo "acceptableLossPct = $max_drop_pct," >>$cfg_file
									if [ "$one_shot" == "y" ]; then
										echo "oneShot = true," >>$cfg_file
									fi
								fi
								if [ "$accept_negative_loss" == "y" ]; then
									echo "negativeLossRetry = false," >>$cfg_file
								fi
        							echo "frameSize = $frame_size,">>$cfg_file
								echo "mppsPerQueue = $mpps_per_queue," >>$cfg_file
								echo "queuesPerTask = $queues_per_task," >>$cfg_file
								if [ -n "$dst_maclist" ]; then
									echo -n "dstMacs = {">>$cfg_file
									for mac in `echo $dst_maclist | sed -e s/,/" "/g`; do
										echo -n "\"$mac\",">>$cfg_file
									done
									echo "},">>$cfg_file
								fi
        							echo "ports = {$portlist}" >>$cfg_file
								echo "}">>$cfg_file
								cp $cfg_file $trafficgen_dir/
								if [ "$test_type" == "throughput" ]; then
									rm $cfg_file
								fi
							fi
							# each attempt at a test config requires multiple samples to get stddev
							for sample in `seq 1 $nr_samples`; do
								benchmark_results_dir="$iteration_dir/sample$sample"
								if [ "$postprocess_only" != "y" ]; then
									mkdir -p $benchmark_results_dir
									echo "test sample $sample of $nr_samples"
									log "test sample $sample of $nr_samples "
									benchmark_client_cmd_file="$iteration_dir/$benchmark_name-client.cmd"
									result_file=$benchmark_results_dir/trafficgen-result.txt
									# save benchmark command in file for debugging or running manually

									echo "pushd >/dev/null $trafficgen_dir" >$benchmark_client_cmd_file
									echo "./build/MoonGen /root/lua-trafficgen/trafficgen.lua" >>$benchmark_client_cmd_file
									echo "popd >/dev/null" >>$benchmark_client_cmd_file
									chmod +x $benchmark_client_cmd_file

									rm -f $trafficgen_dir/latency*.csv 2> /dev/null
									pbench-start-tools --group=$tool_group --iteration=$iteration --dir=$benchmark_results_dir
									$benchmark_client_cmd_file 2>&1 | tee $result_file
									pbench-stop-tools --group=$tool_group --iteration=$iteration --dir=$benchmark_results_dir
									pbench-postprocess-tools --group=$tool_group --iteration=$iteration --dir=$benchmark_results_dir
									if [ "$test_type" == "latency" -o "$test_type" == "throughput-latency" ]; then
									    cp $trafficgen_dir/latency*.csv $benchmark_results_dir
									    xz $benchmark_results_dir/latency:samples*.csv
									fi
								else
									if [[ ! -d $benchmark_results_dir ]]; then
										error_log "Results directory $benchmark_results_dir does not exist, skipping post-processing"
										continue
									fi
									echo "Not going to run $benchmark_name.  Only postprocesing existing data"
									log "Not going to run $benchmnark_name.  Only postprocesing existing data"
								fi
								echo "$script_path/postprocess/$benchmark_name-postprocess $benchmark_results_dir $iteration $test_type $tool_label_pattern $tool_group" >"$benchmark_results_dir/$benchmark_name-postprocess.cmd"
								chmod +x "$benchmark_results_dir/$benchmark_name-postprocess.cmd"
								$benchmark_results_dir/$benchmark_name-postprocess.cmd
							done
							echo "$script_path/postprocess/process-iteration-samples $iteration_dir Mframes_sec $maxstddevpct $failures $max_failures $tar_nonref_data $keep_failed_tool_data" >"$iteration_dir/process-iteration-samples.cmd"
							chmod +x "$iteration_dir/process-iteration-samples.cmd"
							$iteration_dir/process-iteration-samples.cmd
							fail=$?
							if [ $fail -eq 1 ]; then
								error_log "This test iteration failed"
								((failures++))
							fi
							if [ $fail -eq 0 -o $failures -ge $max_failures ]; then
								debug_log "Moving to the next iteration"
								break
							fi
						done # break out of this loop only if the $result_stddevpct is lower than $maxstddevpct
						echo "Iteration $iteration complete ($count of $total_iterations), with 1 pass and $failures failures"
						log "Iteration $iteration complete ($count of $total_iterations), with 1 pass and $failures failures"
					else
						echo "Skipping iteration $iteration ($count of $total_iterations)"
						log "Skipping iteration $iteration ($count of $total_iterations)"
					fi
					last_test_type="$test_type"
					let count=$count+1 # now we can move to the next iteration
				done
			done
		done
	done
done
echo "$script_path/postprocess/generate-benchmark-summary $benchmark_name $orig_cmd $benchmark_run_dir" >"$benchmark_run_dir/generate-benchmark-summary.cmd"
$script_path/postprocess/generate-benchmark-summary "$benchmark_name" "$orig_cmd" "$benchmark_run_dir"
pbench-collect-sysinfo --group=$tool_group --dir=$benchmark_run_dir end
rmdir $benchmark_run_dir/.running
