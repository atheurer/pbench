#!/bin/bash
# -*- mode: shell-script; indent-tabs-mode: t; sh-basic-offset: 8; sh-indentation: 8; sh-indent-for-case-alt: + -*-

# Author: Andrew Theurer
#
# This is a script to run a network traffic generator like MoonGen or TRex.
# It is intended to test a network function, like a bridge or router.
# 
# Hardware prerequisites:
# - A Linux host with 1 to 2 network adapters.  These adapters must be either Intel XL710 or Intel 82599
#   Ideally this host should have x86-64 processors (current or previous generation) 1GB HW pages, and PCI-E v2 or v3
# - A "device-under-test" (DUT) which network traffic will pass through.
#   The DUT will need to be configured to pass traffic before running this benchmark script
#

# This script attempts to automate potentially a very large number of tests
# This script will take multiple samples of the same test type and try to achieve a standard deviation of <3%
# This script will repeat a test type 6 times in order to try to achieve target stddev.
# If a run (with several samples) fails the stddev, its directory is appended with -fail
# This script will also generate a "results.txt" with a table of all
# results, efficiency, and other stats.

pbench_cmd="$@"
script_path=`dirname $0`
script_name=`basename $0`
pbench_bin="`cd ${script_path}/..; /bin/pwd`"
benchmark_name="trafficgen"
trafficgen_dir="/opt/lua-trafficgen"
# source the base script
. "$pbench_bin"/base

# Every bench-script follows a similar sequence:
# 1) process bench script arguments
# 2) ensure the right version of the benchmark is installed
# 3) gather pre-run state
# 4) run the benchmark and start/stop perf analysis tools
# 5) gather post-run state
# 6) postprocess benchmark data
# 7) postprocess analysis tool data

# Defaults
traffic_generator="trex-txrx" # can be either trex-txrx or moongen-txrx
trex_ver="v2.22"
trex_dir="/opt/trex/$trex_ver"
trex_url=http://trex-tgn.cisco.com/trex/release/${trex_ver}.tar.gz
benchmark_run_dir=""
test_types="throughput-latency"
traffic_directions="bidirec"
max_loss_pcts="0.002"
num_flows="1024"
num_samples=1
rates="none"
rate_tolerance_pct=3 # by percent, how much the TX rate can vary from desired rate
rate_unit="mpps"
devices="" # the network devices as PCI location IDs, like "0000:04:00.0,0000:04:00.1"
dst_ips=""
src_ips=""
dst_macs=""
src_macs=""
encap_dst_ips=""
encap_src_ips=""
encap_dst_macs=""
encap_src_macs=""
frame_sizes="64" # size in bytes of the Ethernet frame inccluding CRC
config=""
maxstddevpct=5 # maximum allowable standard deviation in percent
max_failures=1 # after N failed attempts to hit below $maxstddevpct, move on to the nest test
df_sniff_runtime=30
df_search_runtime=120
df_validation_runtime=300
df_zl_sniff_runtime=30
df_zl_search_runtime=1200
df_zl_validation_runtime=7200
postprocess_only=n
start_iteration_num=1
keep_failed_tool_data="y"
tar_nonref_data="n"
orig_cmd="$*"
tool_group=default
install_only="n"
one_shot="n"
skip_trex_server="n"
flow_mods="src-ip,dst-ip,src-mac,dst-mac"
all_possible_flow_mods="src-ip,dst-ip,src-mac,dst-mac,encap-src-ip,encap-dst-ip,encap-src-mac,encap-dst-mac"
cmd="./binary-search.py"

function kill_trex() {
	# kill any existing trex server process
	trex_pids=`netstat -tlnp | grep -E :4500\|:4501 | awk '{print $7}' | awk -F/ '{print $1}' | sort | uniq`
	if [ ! -z "$trex_pids" ]; then
		echo "killing existing trex server"
		kill $trex_pids
		sleep 5
	fi
}

# Process options and arguments
opts=$(getopt -q -o c: --longoptions "skip-trex-server,traffic-generator:,devices:,rate-unit:,rate:,rates:,rate-tolerance-pct:,max-loss-pct:,max-loss-pcts:,install,start-iteration-num:,config:,num-flows:,test-type:,traffic-direction:,traffic-directions:,sniff-runtime:,search-runtime:,validation-runtime:,frame-size:,frame-sizes:,samples:,max-stddev:,max-failures:,postprocess-only:,run-dir:,tool-group:,one-shot,src-macs:,src-ips:,dst-macs:,dest-ips:,encap-src-macs:,encap-src-ips:,encap-dst-macs:,encapdst-ips:,vlan-ids:,overlay-ids:,overlay-types:,flow-mods:" -n "getopt.sh" -- "$@")
if [ $? -ne 0 ]; then
	printf -- "$*\n"
	printf "\n"
	printf "\t${benchmark_name}: you specified an invalid option\n\n"
	printf "\tThe following options are available:\n\n"
	#                   1         2         3         4         5         6         7         8
	#          12345678901234567890123456789012345678901234567890123456789012345678901234567890
	printf -- "\n"
	printf -- "trafficgen general test options\n"
	printf -- "-------------------------------\n"
	printf -- "\n"
	printf -- "--traffic-generator=str\n"
	printf -- "  The traffic generation engine to use (trex-txrx or moongen-txrx)\n"
	printf -- "  Default is $traffic_generator\n"
	printf -- "\n"
	printf -- "--devices=str,str\n"
	printf -- "  List of 2 DPDK devices to use, by PCI location ID (0000:04:00.0,0000:04:00.1)\n"
	printf -- "  This script will attempt to bind the device to vfio-pci kernel module.\n"
	printf -- "  You must ensure your system has IOMMU enabled.\n"
	printf -- "\n"
	printf -- "--one-shot\n"
	printf -- "  Run one test for throughput at specified rate\n"
	printf -- "\n"
	printf -- "--sniff-runtime=int\n"
	printf -- "  Measurement period in seconds for a \"sniff\" trial, right before the search trial\n"
	printf -- "  if the sniff test fails, the search trial is skipped and moves on to the next trial\n"
	printf -- "  Default is $sniff_runtime\n"
	printf -- "\n"
	printf -- "--search-runtime=int\n"
	printf -- "  Measurement period in seconds when searching for max throughput\n"
	printf -- "  Default is $search_runtime\n"
	printf -- "\n"
	printf -- "--validation-runtime=int\n"
	printf -- "  Measurement period in seconds when running final validation or a latency test\n"
	printf -- "  Default is $validation_runtime\n"
	printf -- "\n\n"
	printf -- "      The follwoing options can take 1 or more values and will control how many\n"
	printf -- "      tests will be conducted.  For example, the following options:\n"
	printf -- "\n"
	printf -- "        --rates=1,2 --traffic-directions=unidirec,bidirec --max-loss-pcts=0,1\n"
	printf -- "        --frame-sizes=64,256 --nr-flows=1024,65536\n"
	printf -- "\n"
	printf -- "      would produce 32 different test permutations\n"
	printf -- "\n"
	printf -- "--rate[s]=value[,value]]\n"
	printf -- "  A list of packet rates, in millions of packets per second (mpps), unless\n"
	printf -- "  --rate-unit=%% is used, where the rate value is interpreted as a percentage\n"
	printf -- "  of line rate for the trasmitting device.\n"
	printf -- "\n"
	printf -- "  Only use this option when:\n"
	printf -- "    1) Using the --one-shot option (skip binary search) and only 1 frame size\n"
	printf -- "      For example, you may want to use this when measuring latency for\n"
	printf -- "      10%%, 50%%, 90%% of line rate with 64-byte frames:\n"
	printf -- "      --rates=10%%,50%%,90%% --rate-unit=%% --frame-size=64 --one-shot\n"
	printf -- "    2) Performing a binary search, but you want the search to start with a rate\n"
	printf -- "       lower than 100%%.  Wen doing this, it is recommended that only 1 frame\n"
	printf -- "       size is used:\n"
	printf -- "       --rate=50%% --rate-unit=%% --frame-size=64\n"
	printf -- "\n"
	printf -- "--traffic-direction[s]=str[,str]\n"
	printf -- "  A list of one or more: unidirec or bidirec (default $traffic_directions)\n"
	printf -- "  unidirec: packets will Tx out the 1st device and Rx in the 2nd device\n"
	printf -- "  biidirec: packets will Tx out the both devices and Rx in both devices\n"
	printf -- "\n"
	printf -- "--max-loss-pct[s]=fl,[fl]\n"
	printf -- "  A list of maximum allowed percentage of dropped frames, used for binary search\n"
	printf -- "  Default is $max_loss_pcts\n"
	printf -- "\n"
	printf -- "--frame-sizes=str[,str]\n"
	printf -- "  A list of Ethernet frame sizes (including CRC) in bytes\n"
	printf -- "  Default is $frame_sizes\n"
	printf -- "\n"
	printf -- "--num-flows=int\n"
	printf -- "  Number of packet flows to run. Default is $num_flows\n"
	printf -- "\n\n"
	#                   1         2         3         4         5         6         7         8
	#          12345678901234567890123456789012345678901234567890123456789012345678901234567890
	printf -- "trafficgen options that control packet contents\n"
	printf -- "-----------------------------------------------\n"
	printf -- "\n"
	printf -- "    The values provided for the following options correspond to the devices\n"
	printf -- "    device list (--devices).  For example\n"
	printf -- "\n"
	printf -- "      --devices=0000:04:00.0,0000:04:00.1 --src-ips=10.0.0.1,8.0.0.1\n"
	printf -- "\n"
	printf -- "    In the example above, device 0000:04:00.0 would use source IP address 10.0.0.1\n"
	printf -- "    and device 0000:04:00.1 would use source IP adress 8.0.0.1\n"
	printf -- "\n"
	printf -- "--src-macs=MAC,MAC\n"
	printf -- "  MAC \n"
	printf -- "  A list of two source MAC addresses\n"
	printf -- "\n"
	printf -- "--src-ips=IP,IP\n"
	printf -- "  A list of two source IP addresses\n"
	printf -- "\n"
	printf -- "--dst-macs=MAC,MAC\n"
	printf -- "  A list of two destination MAC addresses\n"
	printf -- "\n"
	printf -- "--dst-ips=IP,IP\n"
	printf -- "  A list of two destination IP addresses\n"
	printf -- "\n"
	printf -- "--encap-src-macs=MAC,MAC\n"
	printf -- "  A list of two source MAC addresses for the encapsulated network. Only used in\n"
	printf -- "  conjuction with an overlay network like VxLAN\n"
	printf -- "\n"
	printf -- "--encap-src-ips=IP,IP\n"
	printf -- "  A list of two source IP addresses for the encapsulated network.  Only used in\n"
	printf -- "  conjuction with an overlay network like VxLAN.\n"
	printf -- "\n"
	printf -- "--encap-dst-macs=MAC,MAC\n"
	printf -- "  A list of two destination MAC addresses for the encapsulated network.  Only\n"
	printf -- "  used on conjuction with an overlay network like VxLAN.\n"
	printf -- "\n"
	printf -- "--encap-dst-ips=IP,IP\n"
	printf -- "  A list of two destination IP addresses for the encapsulated network.  Only\n"
	printf -- "  used on conjuction with an overlay network like VxLAN.\n"
	printf -- "\n"
	printf -- "--vlan-ids=[int][,int]\n"
	printf -- "  If a value is provided, the corresponding device will use a VLAN tag when\n"
	printf -- "  transmitting and expect received packets to also have the VLAN tag\n"
	printf -- "\n"
	printf -- "--overlay-ids=[int][,int]\n"
	printf -- "  If a value is provided, the corresponding device will encapsulate the packet\n"
	printf -- "  and use VNI = value provided when transmitting packets.  Received packets\n"
	printf -- "  for the this device are expected to be encapsulated and use same VNI.  This\n"
	printf -- "  option must be used with --overlay-type option\n"
	printf -- "\n"
	#                   1         2         3         4         5         6         7         8
	#          12345678901234567890123456789012345678901234567890123456789012345678901234567890
	printf -- "--overlay-types\n"
	printf -- "  Per device specification of overlay network type, can be \"none\", or skipped,\n"
	printf -- "  or \"VxLAN\".  If \"VxLAN\" is used, --overlay-ids must also be used as well\n"
	printf -- "  as --encap-[src|dst]-[macs|ips] options.  When using an overlay, the\n"
	printf -- "  device-under-test must have the matching configuration.  For example, if\n"
	printf -- "  --overlay-types=none,vxlan is used, the device-under-test would receive\n"
	printf -- "  non-overlay packets on its first device, encapsulate the packets, and send\n"
	printf -- "  the packet out the second device.  Packets received by the second device are\n"
	printf -- "  expected to already be encapsulated, and the device-under-test would\n"
	printf -- "  decapsulate them and send them out the first device.\n"
	printf -- "\n"
	printf -- "--flow-mods=str[,str] (default is $flow_mods)\n"
	printf -- "  A list of IP packet header fields which are used to implement unique flows.\n"
	printf -- "  All fields listed here are changed in unison, for example if \"src-ip,src-mac\"\n"
	printf -- "  are used, the first packet will have a source IP of 192.168.0.X and source MAC\n"
	printf -- "  of 01:02:03:04:X:06.  The second packet will have a source IP of\n"
	printf -- "  192.168.0.(X+1) and source MAC of 01:02:03:04:(X+1):06. The list of available\n"
	printf -- "  flow mods are: src-ip,src-mac,src-port,dst-port,encap-src-mac,encap-src-ip\n"
	printf -- "  Note that the encap-* flow mods are only viable for overlay network tests like\n"
	printf -- "  VxLAN, and alter the inner packet header.\n"
	printf -- "  The maximum number of unique flows may be limited by the traffic-generator used.\n"
	printf -- "  For trex-txrx, it is 16.7 million.  Trex-txrx modifies the 2nd, 3rd, and 4th\n"
	printf -- "  octet in the IP addresses and the 3rd, 4th, and 5th octet in the MAC addresses\n"
	printf -- "  When using source or destination ports numbers, the range is limited to 1-32768\n"
	printf -- "  and higher flow counts will \"roll\" over back to 1\n"
	printf -- "\n\n"
	printf -- "trafficgen debug options\n"
	printf -- "-----------------------------------------------\n"
	printf -- "\n"
	printf -- "--skip-trex-server\n"
	printf -- "  Do no kill existing or start a new TRex server process (assumes you have one\n"
	printf -- "  running already)\n"
	printf -- "\n\n"
	printf -- "options common in most pbench benchmark scripts\n"
	printf -- "-----------------------------------------------\n"
	printf -- "\n"
	printf -- "--config=str\n"
	printf -- "  Name of the test config (i.e. jumbo_frames_and_network_throughput)\n"
	printf -- "\n"
	printf -- "--samples=int\n"
	printf -- "  The number of times each different test is run (to compute average)\n"
	printf -- "\n"
	printf -- "--max-failures=int\n"
	printf -- "  The maximm number of failures to get below stddev\n"
	printf -- "\n"
	printf -- "--max-stddev=int\n"
	printf -- "  The maximm percent stddev allowed to pass\n"
	printf -- "\n"
	printf -- "--postprocess-only=y|n\n"
	printf -- "  Don't run the benchmark, but postprocess data from previous test\n"
	printf -- "\n"
	printf -- "--run-dir=str\n"
	printf -- "  Optionally specify what directory should be used (usually only used if\n"
	printf -- "  postprocess-only=y)\n"
	printf -- "\n"
	printf -- "--start-iteration-num=int\n"
	printf -- "  Optionally skip the first (n-1) tests\n"
	printf -- "\n"
	printf -- "--tool-group=str\n"
	printf -- "  Start/stop/post-process tools using this group\n"
	exit 1
fi
eval set -- "$opts"
debug_log "[$script_name]processing options"
while true; do
	case "$1" in
		--install)
		shift
		install_only="y"
		exit
		;;
		--tool-label-pattern)
		shift
		if [ -n "$1" ]; then
			tool_label_pattern="$1"
			shift
		fi
		;;
		--postprocess-only)
		shift
		if [ -n "$1" ]; then
			postprocess_only="$1"
			shift
		fi
		;;
		--run-dir)
		shift
		if [ -n "$1" ]; then
			benchmark_run_dir="$1"
			shift
		fi
		;;
		--max-stddev)
		shift
		if [ -n "$1" ]; then
			maxstddevpct="$1"
			shift
		fi
		;;
		--max-failures)
		shift
		if [ -n "$1" ]; then
			max_failures="$1"
			shift
		fi
		;;
		--samples)
		shift
		if [ -n "$1" ]; then
			num_samples="$1"
			shift
		fi
		;;
		--traffic-generator)
		shift
		if [ -n "$1" ]; then
			traffic_generator="$1"
			shift
		fi
		;;
		--num-flows)
		shift
		if [ -n "$1" ]; then
			num_flows="$1"
			shift
		fi
		;;
		--rate-unit)
		shift
		if [ -n "$1" ]; then
			rate_unit="$1"
			shift
		fi
		;;
		--rate|--rates)
		shift
		if [ -n "$1" ]; then
			rates="$1"
			shift
		fi
		;;
		--rate-tolerance-pct)
		shift
		if [ -n "$1" ]; then
			rate_tolerance_pct="$1"
			shift
		fi
		;;
		--max-loss-pct|--max-loss-pcts)
		shift
		if [ -n "$1" ]; then
			max_loss_pcts="$1"
			shift
		fi
		;;
		--traffic-direction|--traffic-directions)
		shift
		if [ -n "$1" ]; then
			traffic_directions="$1"
			shift
		fi
		;;
		--tool-group)
		shift
		if [ -n "$1" ]; then
			tool_group="$1"
			shift
		fi
		;;
		--frame-size|--frame-sizes)
		shift
		if [ -n "$1" ]; then
			frame_sizes="$1"
			shift
		fi
		;;
		--devices)
		shift
		if [ -n "$1" ]; then
			devices="$1"
			shift
		fi
		;;
		--config)
		shift
		if [ -n "$1" ]; then
			config="$1"
			shift
		fi
		;;
		--start-iteration-num)
		shift
		if [ -n "$1" ]; then
			start_iteration_num=$1
			shift
		fi
		;;
		--one-shot)
		shift
		one_shot="y"
		;;
		--flow-mods)
		shift
		if [ -n "$1" ]; then
		    flow_mods="$1"
		    shift
		fi
		;;
		--validation-runtime|--sniff-runtime|--search-runtime)
		arg="$1"
		shift
		if [ -n "$1" ]; then
			val=$1
			var=`echo $arg | sed -e s/^--// -e s/-/_/g`
			eval $var=$val
		shift
		fi
		;;
		# for options which if not used, do not affect the binary-search.py options (and binary-search should not use them by default)
		--overlay-ids|vlan-ids|overlay-types|--src-ips|--src-macs|--dst-ips|--src-macs|--encap-src-ips|--encap-src-macs|--encap-dst-ips|--encap-dst-macs)
		arg="$1"
		shift
		if [ -n "$1" ]; then
			val=$1
			cmd="$cmd $arg=$val"
			var=`echo $arg | sed -e s/^--// -e s/-/_/g`
			eval $var=$val
		shift
		fi
		;;
		--skip-trex-server)
		shift
		skip_trex_server="y"
		;;
		--)
		shift
		break
		;;
		*)
		error_log "[$script_name] bad option, \"$1 $2\""
		break
		;;
	esac
done


if [ "$traffic_generator" == "trex-txrx" -o "$traffic_generator" == "moongen-txrx" ]; then
	cmd="$cmd --traffic-generator=$traffic_generator --rate-tolerance=$rate_tolerance_pct"
else
	warn_log "The traffic engine is not valid: $traffic_generator"
	exit 1
fi

for num_flow in `echo $num_flows | sed -e 's/,/ /g'`; do
	if ! [ $num_flows -gt 0 -a $num_flows -le 16777216 ]; then
		log_warn "This number of flows is invalid: $num_flow"
		exit 1
	fi
done

not_flow_mods="$all_possible_flow_mods"
for flow_mod in `echo $flow_mods | sed -e 's/,/ /g'`; do
	found_flow_mod=0
	for this_flow_mod in `echo $all_possible_flow_mods | sed -e 's/,/ /g'`; do
		if [ $flow_mod = $this_flow_mod ]; then
			cmd="$cmd --use-${flow_mod}=1"
			found_flow_mod=1
			not_flow_mods=`echo $not_flow_mods | sed -e s/^$flow_mod,// -e s/,$flow-mod,/,/`
		fi
	done
	if [ $found_flow_mod -eq 0 ]; then
		warn_log "This flow_mod is invalid: $flow_mod"
		exit 1
	fi
done
# ensure the other flows are forced off (avoiding any defaults from binary-search.py)
for flow_mod in `echo $not_flow_mods | sed -e 's/,/ /g'`; do
	cmd="$cmd --use-${flow_mod}=0"
done

if [ $one_shot == "y" ]; then
	cmd="$cmd --one-shot=1"
fi

# Before running any tests, the following must be satisfied:
# -IOMMU must be enabled
if cat /proc/cmdline | grep -q iommu; then
	echo "found IOMMU option, continuing"
else
	warn_log "could not find IOMMU option in /proc/cmdline, exiting"
	exit 1
fi
# -dpdk-tools package must be installed
if check_install_rpm dpdk-tools; then
	echo "found dpdk-tools, continuing"
else
	warn_log "could not find dpdk-tools, exiting"
	exit 1
fi
# -PCI devices bound to vfio-pci
if [ -z "$devices" ]; then
	warn_log "no devices were provided (--devices), exiting"
	exit 1
fi
for dev in `echo $devices | sed -e s/,/" "/g`; do
	echo "configuring device $dev"
	if /bin/ls /sys/module/vfio_pci/drivers/pci\:vfio-pci/ | grep -q "$dev"; then
		echo "device $dev already bound to vfio-pci"
	else
		if dpdk-devbind -u $dev; then
			dpdk-devbind -b vfio-pci $dev
		else
			log_warn "could not unbind device"
			exit 1
		fi
	fi
done
# -trafficgen-engine installed/ready
if [ 0 -eq 1 ]; then
if [ -d $trafficgen_dir ]; then
	if pushd $trafficgen_dir >/dev/null && git pull && git checkout master; then
		echo "lua-trafficgen is up to date"
		popd >/dev/null
	#else
		#warn_log "could not get latest lua-trafficgen"
		#exit 1
	fi
else
	if pushd /opt >/dev/null && git clone https://github.com/atheurer/lua-trafficgen.git; then
		echo "lua-trafficgen is up to date"
		popd >/dev/null
	else
		warn_log "could not get latest lua-trafficgen"
		exit 1
	fi
fi

# Moongen is built under the lua-trafficgen repo
if [ $traffic_generator == "moongen-txrx" ]; then
	if ! [ -x $trafficgen_dir/MoonGen/build/MoonGen ]; then
		pushd >/dev/null $trafficgen_dir
		echo "building MoonGen"
		if ./setup.sh; then
			echo "MoonGen build complete"
		else
			warn_log "could not build MoonGen"
			exit 1
		fi
	fi
fi
fi
	
if [ $traffic_generator == "trex-txrx" -a $skip_trex_server == "n" ]; then
	kill_trex
	if [ -d $trex_dir ]; then
		echo "TRex $trex_ver already installed"
	else
		mkdir -p /opt/trex
		pushd /opt/trex >/dev/null
		tarfile="/tmp/${trex_ver}.tar.gz"
		/bin/rm -f $tarfile
		if wget -O $tarfile $trex_url &&\
		   tar zxf $tarfile; then
			/bin/rm $tarfile
			echo "installed TRex from $trex_url"
		else
			warn_log "could not install TRex $trex_ver, exiting"
			exit 1
		fi
		popd >/dev/null
	fi

	# we need a symlink so trex client scripts can always point to
	# same location for trex libraries
	pushd /opt/trex >/dev/null
	/bin/rm -f current
	ln -sf $trex_ver current
	popd >/dev/null

	# start the trex server
	echo "sarting TRex server"
	pushd $trex_dir >/dev/null
	/bin/rm -f $pbench_tmp/trex_cfg.yaml
	./dpdk_setup_ports.py -c `echo $devices | sed -e s/,/" "/g` -o $pbench_tmp/trex_cfg.yaml
	screen -dmS trex-server ./t-rex-64 -i -c 8 --checksum-offload --cfg $pbench_tmp/trex_cfg.yaml
	popd >/dev/null
	# wait for trex server to be ready
	count=30
	num_ports=0
	while [ $count -gt 0 -a $num_ports -lt 2 ]; do
		sleep 1
		num_ports=`netstat -tln | grep -E :4500\|:4501 | wc -l`
		((count--))
	done
	if [ $num_ports -eq 2 ]; then
		echo "trex-server is ready"
	else
		warn_log "trex-server could not start properly.  check \'screen -x trex-server\'"
        exit 1
	fi
fi

if [[ -z "$benchmark_run_dir" ]]; then
	# We don't have an explicit run directory, construct one
	benchmark_fullname="${benchmark_name}_${config}_${date}"
	benchmark_run_dir="$pbench_run/${benchmark_fullname}"
else
	# We have an explicit run directory provided by --run-dir, so warn
	# the user if they also used --config
	if [[ ! -z "$config" ]]; then
		warn_log "[$script_name] ignoring --config=\"$config\" in favor of --rundir=\"$benchmark_run_dir\""
	fi
	benchmark_fullname=$(basename $benchmark_run_dir)
fi
benchmark_iterations="$pbench_tmp/${benchmark_fullname}.iterations"
mkdir -p $benchmark_run_dir/.running
# save a copy of the command, in case the test needs to be reproduced or post-processed again
echo "$script_name $pbench_cmd" >$benchmark_run_dir/$script_name.cmd
chmod +x $benchmark_run_dir/$script_name.cmd

total_iterations=0
for traffic_direction in `echo $traffic_directions | sed -e s/,/" "/g`; do
	for max_loss_pct in `echo $max_loss_pcts | sed -e s/,/" "/g`; do
		for frame_size in `echo $frame_sizes | sed -e s/,/" "/g`; do
			for num_flow in `echo $num_flows | sed -e s/,/" "/g`; do
				((total_iterations++))
			done
		done
	done
done
echo "Total number of benchmark iterations: $total_iterations"
count=1
mkdir -p $benchmark_run_dir/.running
export benchmark_name config
#pbench-collect-sysinfo --group=$tool_group --dir=$benchmark_run_dir beg

for rate in `echo $rates | sed -e s/,/" "/g`; do
	for traffic_direction in `echo $traffic_directions | sed -e s/,/" "/g`; do
		for max_loss_pct in `echo $max_loss_pcts | sed -e s/,/" "/g`; do
			# if any of the runtimes are provided by the user, then use those
			unset iteration_sniff_runtime
			unset iteration_search_runtime
			unset iteration_validation_runtime
			if [ ! -z "$sniff_runtime" ]; then
				iteration_sniff_runtime=$sniff_runtime
			fi
			if [ ! -z "$search_runtime" ]; then
				iteration_search_runtime=$search_runtime
			fi
			if [ ! -z "$validation_runtime" ]; then
				iteration_validation_runtime=$validation_runtime
			fi
			# for any runtimes not provided by user, assign a default value
			# there are different defaults for 0-loss and non-zero-loss
			if [ -z "$iteration_sniff_runtime" ]; then
				if [ $max_loss_pct -eq 0 ]; then
					iteration_sniff_runtime=$df_zl_sniff_runtime
				else
					iteration_sniff_runtime=$df_sniff_runtime
				fi
			fi
			if [ -z "$iteration_search_runtime" ]; then
				if [ $max_loss_pct -eq 0 ]; then
					iteration_search_runtime=$df_zl_search_runtime
				else
					iteration_search_runtime=$df_search_runtime
				fi
			fi
			if [ -z "$iteration_validation_runtime" ]; then
				if [ $max_loss_pct -eq 0 ]; then
					iteration_validation_runtime=$df_zl_validation_runtime
				else
					iteration_validation_runtime=$df_validation_runtime
				fi
			fi
			cmd="$cmd --sniff-runtime=$iteration_sniff_runtime"
			cmd="$cmd --search-runtime=$iteration_search_runtime"
			cmd="$cmd --validation-runtime=$iteration_validation_runtime"
			for frame_size in `echo $frame_sizes | sed -e s/,/" "/g`; do
				for num_flow in `echo $num_flows | sed -e s/,/" "/g`; do
					if [ $count -ge $start_iteration_num ]; then
						iteration_options=""
						if [ $rate == "none" ]; then
							if [ $traffic_generator == "trex-txrx" ]; then
								iteration_options="$iteration_options --rate-unit=% --rate=100"
							else
								# don't specify a rate and let binary-search.py + whatever traffic-generator figure it out
								iteration_options="$iteration_options"
							fi
						else
							iteration_options="$iteration_options --rate-unit=$rate_unit --rate=$rate"
						fi
						if [ "$test_type" == "latency" ]; then
							iteration="${count}-${test_type}-${traffic_direction}-${frame_size}B-${num_flow}flows-${rate}Mpps"
						else 
							iteration="${count}-${test_type}-${traffic_direction}-${frame_size}B-${num_flow}flows-${max_loss_pct}pct_drop"
						fi
                                                echo $iteration >> $benchmark_iterations
						iteration_dir="$benchmark_run_dir/$iteration"
						mkdir -p $iteration_dir
						benchmark_cmd_file="$iteration_dir/$benchmark_name.cmd"
						result_stddevpct=$maxstddevpct # this test case will get a "do-over" if the stddev is not low enough
						failures=0
						echo "Starting iteration[$iteration] ($count of $total_iterations)"
						log "Starting iteration[$iteration] ($count of $total_iterations)"
						# Add any benchmark-iteration-specific options
						if [  $traffic_direction == "unidirec" ]; then
							iteration_options="$iteration_options --run-bidirec=0"
						else
							iteration_options="$iteration_options --run-bidirec=1"
						fi
						iteration_options="$iteration_options --max-loss-pct=$max_loss_pct"
						iteration_options="$iteration_options --frame-size=$frame_size"
						iteration_options="$iteration_options --num-flows=$num_flows"
						# save benchmark command in file for debugging or running manually
						echo "pushd >/dev/null $trafficgen_dir" >$benchmark_cmd_file
						echo "$cmd $iteration_options" >>$benchmark_cmd_file
						echo "popd >/dev/null" >>$benchmark_cmd_file
						chmod +x $benchmark_cmd_file
						while [[ $(echo "if (${result_stddevpct} >= ${maxstddevpct}) 1 else 0" | bc) -eq 1 ]]; do
							if [[ $failures -gt 0 ]]; then
								echo "Restarting iteration[$iteration] ($count of $total_iterations)"
								log "Restarting iteration[$iteration] ($count of $total_iterations)"
							fi
							# each attempt at a test config requires multiple samples to get stddev
							for sample in `seq 1 $num_samples`; do
								benchmark_results_dir="$iteration_dir/sample$sample"
								if [ "$postprocess_only" != "y" ]; then
									mkdir -p $benchmark_results_dir
									echo "test sample $sample of $num_samples"
									log "test sample $sample of $num_samples "
									result_file=$benchmark_results_dir/result.txt


									pbench-start-tools --group=$tool_group --iteration=$iteration --dir=$benchmark_results_dir
									$benchmark_cmd_file | tee $result_file
									pbench-stop-tools --group=$tool_group --iteration=$iteration --dir=$benchmark_results_dir
									pbench-postprocess-tools --group=$tool_group --iteration=$iteration --dir=$benchmark_results_dir
								else
									if [[ ! -d $benchmark_results_dir ]]; then
										error_log "Results directory $benchmark_results_dir does not exist, skipping post-processing"
										continue
									fi
									echo "Not going to run $benchmark_name.  Only postprocesing existing data"
									log "Not going to run $benchmnark_name.  Only postprocesing existing data"
								fi
								echo "$script_path/postprocess/$benchmark_name-postprocess $benchmark_results_dir $iteration $max_loss_pct $tool_label_pattern $tool_group" >"$benchmark_results_dir/$benchmark_name-postprocess.cmd"
								chmod +x "$benchmark_results_dir/$benchmark_name-postprocess.cmd"
								$benchmark_results_dir/$benchmark_name-postprocess.cmd
							done
							echo "$script_path/postprocess/process-iteration-samples $iteration_dir Mframes_sec $maxstddevpct $failures $max_failures $tar_nonref_data $keep_failed_tool_data" >"$iteration_dir/process-iteration-samples.cmd"
							chmod +x "$iteration_dir/process-iteration-samples.cmd"
							$iteration_dir/process-iteration-samples.cmd
							fail=$?
							if [ $fail -eq 1 ]; then
								error_log "This test iteration failed"
								((failures++))
							fi
							if [ $fail -eq 0 -o $failures -ge $max_failures ]; then
								debug_log "Moving to the next iteration"
								break
							fi
						done # break out of this loop only if the $result_stddevpct is lower than $maxstddevpct
						echo "Iteration $iteration complete ($count of $total_iterations), with 1 pass and $failures failures"
						log "Iteration $iteration complete ($count of $total_iterations), with 1 pass and $failures failures"
					else
						echo "Skipping iteration $iteration ($count of $total_iterations)"
						log "Skipping iteration $iteration ($count of $total_iterations)"
					fi
					last_test_type="$test_type"
					let count=$count+1 # now we can move to the next iteration
				done
			done
		done
	done
done
echo "$script_path/postprocess/generate-benchmark-summary $benchmark_name $orig_cmd $benchmark_run_dir" >"$benchmark_run_dir/generate-benchmark-summary.cmd"
$script_path/postprocess/generate-benchmark-summary "$benchmark_name" "$orig_cmd" "$benchmark_run_dir"
#pbench-collect-sysinfo --group=$tool_group --dir=$benchmark_run_dir end
if [ $traffic_generator == "trex-txrx" -a $skip_trex_server == "n" ]; then
	kill_trex
fi
rmdir $benchmark_run_dir/.running
